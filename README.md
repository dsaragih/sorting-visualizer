# Sorting Algorithm Visualizer

Simple sorting algorithm visualizer made using React. This happens to be my first project wherein I use React hooks and React Bootstrap for the UI components. I encountered some difficulty transferring states across the different components, specifically when transferring the state of the `displays`. As a result awkward function calls such as `displays['handleClick'](i)` were necessary to use the nested object. An alternative approach would be to declare the necessary states inside of `App`, however, distinguishing between the 4 displays would have been messy.

Another motif of this project was the animation of the array whilst sorting. For the algorithms which used a for loop, the animations were quite easy. However, for those that used recursion, there were some problems using async-await within the recursive functions. I noticed that when async-await was applied to certain  locations within a function, the array was not sorted (although without async, the algorithm worked fine). Another issue was the re-indexing within recursive functions, specifically merge sort, wherein the left and right arrays are slices of the original array. As a result, I modified the algorithm so that it sorted recursively in the array itself. Despite this, the async-await problem still plagued the animation.

The solution that I am going to settle with is animation through the use of generator functions (marked by `function*`). Generators allow me to use `yield` to pause the function, and then use `fn.next()` to proceed. Not only did this fix the animation issue, but it also made it unnecessary to pass in context and the draw function as arguments to the sorting algorithm. This is because a draw function in the render function suffices since the algorithm will be running incrementally as per the yield keyword, hence I can animate changes in between iterations. One minor issue that cropped up as a result of generators is the fact that `yield` is not invoked uniformly across algorithms. I noticed that the recursive functions invoked `yield` less than those with `for` loops. As a result, the array would sort slower than it normally would if only time complexity were at play. To fix this, I simply decreased the `setInterval` cycle in the `for` loop algorithms to compensate.

Check out the project [here](https://dsaragih.github.io/sorting-visualizer/)
